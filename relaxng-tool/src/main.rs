use relaxng_model::{Compiler, Syntax};
use relaxng_validator::Validator;

use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::process::exit;

use structopt::StructOpt;

#[derive(Debug, StructOpt)]
enum Cli {
    Validate { schema: PathBuf, xml: Vec<PathBuf> },
}

fn main() {
    match Cli::from_args() {
        Cli::Validate { schema, xml } => validate(schema, xml),
    }
}

fn validate(schema: PathBuf, xmls: Vec<PathBuf>) {
    let syntax = match schema.extension().and_then(|e| e.to_str()) {
        Some("rng") => Syntax::Xml,
        _ => Syntax::Compact,
    };
    let mut compiler = Compiler::new(relaxng_model::FsFiles, syntax);
    let model = match compiler.compile(&schema) {
        Ok(m) => m,
        Err(err) => {
            compiler.dump_diagnostic(&err);
            exit(1);
        }
    };
    for xml in xmls {
        let mut f = File::open(&xml).expect("open example xml");
        let mut doc = String::new();
        f.read_to_string(&mut doc).expect("read xml");
        let src = doc.clone();
        let reader = xmlparser::Tokenizer::from(&src[..]);
        let mut v = Validator::new(model.clone(), reader);
        //v.assert_health();
        eprintln!("Validating {xml:?}");
        loop {
            match v.validate_next() {
                Some(Ok(())) => {}
                Some(Err(err)) => {
                    let (map, d) = v.diagnostic(xml.to_string_lossy().to_string(), doc, &err);
                    let mut emitter = codemap_diagnostic::Emitter::stderr(
                        codemap_diagnostic::ColorConfig::Auto,
                        Some(&map),
                    );
                    emitter.emit(&d[..]);
                    exit(2);
                }
                None => break,
            }
        }
    }
}
